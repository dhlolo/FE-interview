{"ast":null,"code":"import _slicedToArray from \"/Users/houyaodong/test/react/300line/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"/Users/houyaodong/test/react/300line/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\n\nvar _jsxFileName = \"/Users/houyaodong/test/react/300line/src/index.js\",\n    _s = $RefreshSig$();\n\nvar Didact = {\n  createElement: createElement,\n  render: render,\n  useState: useState\n};\n\nfunction createElement(type, props) {\n  for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    children[_key - 2] = arguments[_key];\n  }\n\n  return {\n    type: type,\n    props: _objectSpread(_objectSpread({}, props), {}, {\n      children: children.map(function (child) {\n        return typeof child === 'object' ? child : createTextElement(child);\n      })\n    })\n  };\n}\n\nfunction createTextElement(text) {\n  return {\n    type: 'TEXT_ELEMENT',\n    props: {\n      nodeValue: text,\n      children: []\n    }\n  };\n}\n\nvar isEvent = function isEvent(key) {\n  return key.startsWith('on');\n};\n\nvar isProperty = function isProperty(key) {\n  return key !== 'children' && !isEvent(key);\n};\n\nvar isNew = function isNew(prev, next) {\n  return function (key) {\n    return prev[key] !== next[key];\n  };\n};\n\nvar isGone = function isGone(prev, next) {\n  return function (key) {\n    return !(key in next);\n  };\n};\n\nfunction updateDom(dom, prevProps, nextProps) {\n  //Remove old or changed event listeners\n  Object.keys(prevProps).filter(isEvent).filter(function (key) {\n    return !(key in nextProps) || isNew(prevProps, nextProps)(key);\n  }).forEach(function (name) {\n    var eventType = name.toLowerCase().substring(2);\n    dom.removeEventListener(eventType, prevProps[name]);\n  }); // Add event listeners\n\n  Object.keys(nextProps).filter(isEvent).filter(isNew(prevProps, nextProps)).forEach(function (name) {\n    var eventType = name.toLowerCase().substring(2);\n    dom.addEventListener(eventType, nextProps[name]);\n  }); // Remove old properties\n\n  Object.keys(prevProps).filter(isProperty).filter(isGone(prevProps, nextProps)).forEach(function (name) {\n    dom[name] = '';\n  }); // Set new or changed properties\n\n  Object.keys(nextProps).filter(isProperty).filter(isNew(prevProps, nextProps)).forEach(function (name) {\n    dom[name] = nextProps[name];\n  });\n}\n\nfunction commitRoot() {\n  // TODO add nodes to dom\n  deletions.forEach(commitWork);\n  commitWork(wipRoot.child);\n  currentRoot = wipRoot;\n  wipRoot = null;\n}\n\nfunction commitWork(fiber) {\n  if (!fiber) return; // Now that we have fibers without DOM nodes we need to change in FC supported\n  // const domParent = fiber.parent.dom\n\n  var domParentFiber = fiber.parent;\n\n  while (!domParentFiber.dom) {\n    domParentFiber = domParentFiber.parent;\n  }\n\n  var domParent = domParentFiber.dom; // domParent.appendChild(fiber.dom);\n\n  if (fiber.effectTag === 'PLACEMENT' && fiber.dom != null) {\n    domParent.appendChild(fiber.dom);\n  } else if (fiber.effectTag === 'UPDATE' && fiber.dom != null) {\n    updateDom(fiber.dom, fiber.alternate.props, fiber.props);\n  } else if (fiber.effectTag === 'DELETION') {\n    commitDeletion(fiber, domParent);\n  }\n\n  commmitWork(fiber.child);\n  commmitWork(fiber.sibling);\n}\n\nfunction commitDeletion(fiber, domParent) {\n  if (fiber.dom) {\n    domParent.removeChild(fiber.dom);\n  } else {\n    commitDeletion(fiber.child, domParent);\n  }\n}\n\nfunction render(element, container) {\n  // const dom =\n  //   element.type === 'TEXT_ELEMENT'\n  //     ? document.createTextNode('')\n  //     : document.createElement(element.type);\n  // const isProperty = (key) => key !== 'children';\n  // Object.keys(element.props).filter(isProperty).forEach(name => {\n  //   dom[name] = element.props[name];\n  // })\n  // element.props.children.forEach((child) => render(child, dom));\n  // container.appendChild(dom);\n  wipRoot = {\n    dom: container,\n    props: {\n      children: [element]\n    },\n    alternate: currentRoot\n  };\n  deletions = [];\n  nextUnitOfWork = wipRoot;\n}\n\nvar nextUnitOfWork = null;\nvar wipRoot = null;\nvar currentRoot = null;\nvar deletions = null;\n\nfunction workLoop(deadline) {\n  var shouldYield = false;\n\n  while (nextUnitOfWork && !shouldYield) {\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    shouldYield = deadline.timeRemaining() < 1;\n  }\n\n  if (!nextUnitOfWork && wipRoot) {\n    commitRoot();\n  }\n\n  requestIdleCallback(workLoop);\n}\n\nrequestIdleCallback(workLoop);\n\nfunction performUnitOfWork(fiber) {\n  // if (!fiber.dom) {\n  //   fiber.dom = createDom(fiber);\n  // }\n  // // remove because the browser could interrupt our work before we finish rendering the whole tree\n  // // if (fiber.parent) {\n  // //   fiber.parent.dom.appendDom(fiber.dom);\n  // // }\n  // const elements = fiber.props.children;\n  // reconcileChildren(fiber, elements);\n  var isFunctionComponent = fiber.type instanceof Function;\n\n  if (isFunctionComponent) {\n    updateFunctionComponent(fiber);\n  } else {\n    updateHostComponent(fiber);\n  }\n\n  if (fiber.child) {\n    return fiber.child;\n  }\n\n  var nextFiber = fiber;\n\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling;\n    }\n\n    nextFiber = nextFiber.parent;\n  }\n}\n\nvar wipFiber = null;\nvar hookIndex = null;\n\nfunction updateFunctionComponent(fiber) {\n  wipFiber = fiber;\n  hookIndex = 0;\n  wipFiber.hooks = [];\n  var children = [fiber.type(fiber.props)];\n  reconcileChildren(fiber, children);\n}\n\nfunction useState(initial) {\n  var oldHook = wipFiber.alternate && wipFiber.alternate.hooks && wipFiber.alternate.hooks[hookIndex];\n  var hook = {\n    state: oldHook ? oldHook.state : initial,\n    queue: []\n  };\n  var actions = oldHook ? oldHook.queue : [];\n  actions.forEach(function (action) {\n    hook.state = action(hook.state);\n  });\n\n  var setState = function setState(action) {\n    hook.queue.push(action);\n    wipRoot = {\n      dom: currentRoot.dom,\n      props: currentRoot.props,\n      alternate: currentRoot\n    };\n    nextUnitOfWork = wipRoot;\n    deletions = [];\n  };\n\n  wipFiber.hooks.push(hook);\n  hookIndex++;\n  return [hook.state, setState];\n}\n\nfunction updateHostComponent(fiber) {\n  if (!fiber.dom) {\n    fiber.dom = createDom(fiber);\n  } // remove because the browser could interrupt our work before we finish rendering the whole tree\n  // if (fiber.parent) {\n  //   fiber.parent.dom.appendDom(fiber.dom);\n  // }\n\n\n  var elements = fiber.props.children;\n  reconcileChildren(fiber, elements);\n}\n\nfunction reconcileChildren(wipFiber, elements) {\n  var index = 0;\n  var oldFiber = wipFiber.alternate && wipFiber.alternate.child;\n  var prevSibling = null;\n\n  while (index < elements.length || oldFiber != null) {\n    var _element = elements[index];\n    var newFiber = null; // const newFiber = {\n    //   type: element.type,\n    //   props: element.props,\n    //   parent: wipFiber,\n    //   dom: null\n    // }\n    // compare oldFiber to element\n\n    var sameType = oldFiber && _element && _element.type == oldFiber.type;\n\n    if (sameType) {\n      // update the node\n      newFiber = {\n        type: oldFiber.type,\n        props: _element.props,\n        dom: oldFiber.dom,\n        parent: wipFiber,\n        alternate: oldFiber,\n        effectTag: 'UPDATE'\n      };\n    }\n\n    if (_element && !sameType) {\n      // add the node\n      newFiber = {\n        type: _element.type,\n        props: _element.props,\n        dom: null,\n        parent: wipFiber,\n        alternate: null,\n        effectTag: 'PLACEMENT'\n      };\n    }\n\n    if (oldFiber && !sameType) {\n      // delete the node\n      oldFiber.effectTag = 'DELETION';\n      deletions.push(oldFiber);\n    }\n\n    if (oldFiber) {\n      oldFiber = oldFiber.sibling;\n    }\n\n    if (index === 0) {\n      wipFiber.child = newFiber;\n    } else {\n      prevSibling.sibling = newFiber;\n    }\n\n    prevSibling = newFiber;\n    index++;\n  }\n}\n/** @jsxRuntime classic */\n\n/** @jsx Didact.createElement */\n\n\nfunction Counter() {\n  _s();\n\n  var _Didact$useState = Didact.useState(1),\n      _Didact$useState2 = _slicedToArray(_Didact$useState, 2),\n      state = _Didact$useState2[0],\n      setState = _Didact$useState2[1];\n\n  return Didact.createElement(\"h1\", {\n    onClick: function onClick() {\n      return setState(function (c) {\n        return c + 1;\n      });\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 298,\n      columnNumber: 10\n    }\n  }, \"Count: \", state);\n}\n\n_s(Counter, \"akakBhCEomgH04pZyWr7fNqgJTI=\");\n\n_c = Counter;\nvar element = Didact.createElement(Counter, {\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 300,\n    columnNumber: 17\n  }\n});\nvar container = document.getElementById('root');\nDidact.render(element, container);\n\nvar _c;\n\n$RefreshReg$(_c, \"Counter\");","map":{"version":3,"sources":["/Users/houyaodong/test/react/300line/src/index.js"],"names":["Didact","createElement","render","useState","type","props","children","map","child","createTextElement","text","nodeValue","isEvent","key","startsWith","isProperty","isNew","prev","next","isGone","updateDom","dom","prevProps","nextProps","Object","keys","filter","forEach","name","eventType","toLowerCase","substring","removeEventListener","addEventListener","commitRoot","deletions","commitWork","wipRoot","currentRoot","fiber","domParentFiber","parent","domParent","effectTag","appendChild","alternate","commitDeletion","commmitWork","sibling","removeChild","element","container","nextUnitOfWork","workLoop","deadline","shouldYield","performUnitOfWork","timeRemaining","requestIdleCallback","isFunctionComponent","Function","updateFunctionComponent","updateHostComponent","nextFiber","wipFiber","hookIndex","hooks","reconcileChildren","initial","oldHook","hook","state","queue","actions","action","setState","push","createDom","elements","index","oldFiber","prevSibling","length","newFiber","sameType","Counter","c","document","getElementById"],"mappings":"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","sourcesContent":["const Didact = {\n  createElement,\n  render,\n  useState,\n};\n\nfunction createElement(type, props, ...children) {\n  return {\n    type,\n    props: {\n      ...props,\n      children: children.map((child) =>\n        typeof child === 'object' ? child : createTextElement(child)\n      ),\n    },\n  };\n}\n\nfunction createTextElement(text) {\n  return {\n    type: 'TEXT_ELEMENT',\n    props: {\n      nodeValue: text,\n      children: [],\n    },\n  };\n}\n\nconst isEvent = (key) => key.startsWith('on');\nconst isProperty = (key) => key !== 'children' && !isEvent(key);\nconst isNew = (prev, next) => (key) => prev[key] !== next[key];\nconst isGone = (prev, next) => (key) => !(key in next);\n\nfunction updateDom(dom, prevProps, nextProps) {\n  //Remove old or changed event listeners\n  Object.keys(prevProps)\n    .filter(isEvent)\n    .filter((key) => !(key in nextProps) || isNew(prevProps, nextProps)(key))\n    .forEach((name) => {\n      const eventType = name.toLowerCase().substring(2);\n      dom.removeEventListener(eventType, prevProps[name]);\n    });\n  // Add event listeners\n  Object.keys(nextProps)\n    .filter(isEvent)\n    .filter(isNew(prevProps, nextProps))\n    .forEach((name) => {\n      const eventType = name.toLowerCase().substring(2);\n      dom.addEventListener(eventType, nextProps[name]);\n    });\n  // Remove old properties\n  Object.keys(prevProps)\n    .filter(isProperty)\n    .filter(isGone(prevProps, nextProps))\n    .forEach((name) => {\n      dom[name] = '';\n    });\n  // Set new or changed properties\n  Object.keys(nextProps)\n    .filter(isProperty)\n    .filter(isNew(prevProps, nextProps))\n    .forEach((name) => {\n      dom[name] = nextProps[name];\n    });\n}\n\nfunction commitRoot() {\n  // TODO add nodes to dom\n  deletions.forEach(commitWork);\n  commitWork(wipRoot.child);\n  currentRoot = wipRoot;\n  wipRoot = null;\n}\n\nfunction commitWork(fiber) {\n  if (!fiber) return;\n  // Now that we have fibers without DOM nodes we need to change in FC supported\n  // const domParent = fiber.parent.dom\n  let domParentFiber = fiber.parent;\n  while (!domParentFiber.dom) {\n    domParentFiber = domParentFiber.parent;\n  }\n  const domParent = domParentFiber.dom;\n\n  // domParent.appendChild(fiber.dom);\n  if (fiber.effectTag === 'PLACEMENT' && fiber.dom != null) {\n    domParent.appendChild(fiber.dom);\n  } else if (fiber.effectTag === 'UPDATE' && fiber.dom != null) {\n    updateDom(fiber.dom, fiber.alternate.props, fiber.props);\n  } else if (fiber.effectTag === 'DELETION') {\n    commitDeletion(fiber, domParent);\n  }\n  commmitWork(fiber.child);\n  commmitWork(fiber.sibling);\n}\n\nfunction commitDeletion(fiber, domParent) {\n  if (fiber.dom) {\n    domParent.removeChild(fiber.dom);\n  } else {\n    commitDeletion(fiber.child, domParent);\n  }\n}\n\nfunction render(element, container) {\n  // const dom =\n  //   element.type === 'TEXT_ELEMENT'\n  //     ? document.createTextNode('')\n  //     : document.createElement(element.type);\n  // const isProperty = (key) => key !== 'children';\n  // Object.keys(element.props).filter(isProperty).forEach(name => {\n  //   dom[name] = element.props[name];\n  // })\n  // element.props.children.forEach((child) => render(child, dom));\n  // container.appendChild(dom);\n  wipRoot = {\n    dom: container,\n    props: {\n      children: [element],\n    },\n    alternate: currentRoot,\n  };\n  deletions = [];\n  nextUnitOfWork = wipRoot;\n}\n\nlet nextUnitOfWork = null;\nlet wipRoot = null;\nlet currentRoot = null;\nlet deletions = null;\n\nfunction workLoop(deadline) {\n  let shouldYield = false;\n  while (nextUnitOfWork && !shouldYield) {\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    shouldYield = deadline.timeRemaining() < 1;\n  }\n\n  if (!nextUnitOfWork && wipRoot) {\n    commitRoot();\n  }\n  requestIdleCallback(workLoop);\n}\n\nrequestIdleCallback(workLoop);\n\nfunction performUnitOfWork(fiber) {\n  // if (!fiber.dom) {\n  //   fiber.dom = createDom(fiber);\n  // }\n\n  // // remove because the browser could interrupt our work before we finish rendering the whole tree\n  // // if (fiber.parent) {\n  // //   fiber.parent.dom.appendDom(fiber.dom);\n  // // }\n\n  // const elements = fiber.props.children;\n  // reconcileChildren(fiber, elements);\n\n  const isFunctionComponent = fiber.type instanceof Function;\n  if (isFunctionComponent) {\n    updateFunctionComponent(fiber);\n  } else {\n    updateHostComponent(fiber);\n  }\n\n  if (fiber.child) {\n    return fiber.child;\n  }\n  let nextFiber = fiber;\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling;\n    }\n    nextFiber = nextFiber.parent;\n  }\n}\n\nlet wipFiber = null;\nlet hookIndex = null;\nfunction updateFunctionComponent(fiber) {\n  wipFiber = fiber;\n  hookIndex = 0;\n  wipFiber.hooks = [];\n  const children = [fiber.type(fiber.props)];\n  reconcileChildren(fiber, children);\n}\n\nfunction useState(initial) {\n  const oldHook =\n    wipFiber.alternate &&\n    wipFiber.alternate.hooks &&\n    wipFiber.alternate.hooks[hookIndex];\n  const hook = {\n    state: oldHook ? oldHook.state : initial,\n    queue: []\n  };\n  const actions = oldHook ? oldHook.queue : []\n  actions.forEach(action => {\n    hook.state = action(hook.state)\n  })\n  \n  const setState = action => {\n    hook.queue.push(action);\n    wipRoot = {\n      dom: currentRoot.dom,\n      props: currentRoot.props,\n      alternate: currentRoot\n    }\n    nextUnitOfWork = wipRoot;\n    deletions = [];\n  };\n  wipFiber.hooks.push(hook)\n  hookIndex++\n  return [hook.state, setState]\n}\n\nfunction updateHostComponent(fiber) {\n  if (!fiber.dom) {\n    fiber.dom = createDom(fiber);\n  }\n\n  // remove because the browser could interrupt our work before we finish rendering the whole tree\n  // if (fiber.parent) {\n  //   fiber.parent.dom.appendDom(fiber.dom);\n  // }\n\n  const elements = fiber.props.children;\n  reconcileChildren(fiber, elements);\n}\n\nfunction reconcileChildren(wipFiber, elements) {\n  let index = 0;\n  let oldFiber = wipFiber.alternate && wipFiber.alternate.child;\n  let prevSibling = null;\n\n  while (index < elements.length || oldFiber != null) {\n    const element = elements[index];\n    let newFiber = null;\n\n    // const newFiber = {\n    //   type: element.type,\n    //   props: element.props,\n    //   parent: wipFiber,\n    //   dom: null\n    // }\n\n    // compare oldFiber to element\n    const sameType = oldFiber && element && element.type == oldFiber.type;\n\n    if (sameType) {\n      // update the node\n      newFiber = {\n        type: oldFiber.type,\n        props: element.props,\n        dom: oldFiber.dom,\n        parent: wipFiber,\n        alternate: oldFiber,\n        effectTag: 'UPDATE',\n      };\n    }\n    if (element && !sameType) {\n      // add the node\n      newFiber = {\n        type: element.type,\n        props: element.props,\n        dom: null,\n        parent: wipFiber,\n        alternate: null,\n        effectTag: 'PLACEMENT',\n      };\n    }\n    if (oldFiber && !sameType) {\n      // delete the node\n      oldFiber.effectTag = 'DELETION';\n      deletions.push(oldFiber);\n    }\n\n    if (oldFiber) {\n      oldFiber = oldFiber.sibling;\n    }\n\n    if (index === 0) {\n      wipFiber.child = newFiber;\n    } else {\n      prevSibling.sibling = newFiber;\n    }\n\n    prevSibling = newFiber;\n    index++;\n  }\n}\n\n/** @jsxRuntime classic */\n/** @jsx Didact.createElement */\nfunction Counter() {\n  const [state, setState] = Didact.useState(1);\n  return <h1 onClick={() => setState((c) => c + 1)}>Count: {state}</h1>;\n}\nconst element = <Counter />;\nconst container = document.getElementById('root');\nDidact.render(element, container);\n"]},"metadata":{},"sourceType":"module"}