{"ast":null,"code":"import _slicedToArray from \"/Users/houyaodong/test/react/300line/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"/Users/houyaodong/test/react/300line/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\n\nvar _jsxFileName = \"/Users/houyaodong/test/react/300line/src/index.js\",\n    _s = $RefreshSig$();\n\nvar Didact = {\n  createElement: createElement,\n  render: render,\n  useState: useState\n};\n\nfunction createElement(type, props) {\n  for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    children[_key - 2] = arguments[_key];\n  }\n\n  return {\n    type: type,\n    props: _objectSpread(_objectSpread({}, props), {}, {\n      children: children.map(function (child) {\n        return typeof child === 'object' ? child : createTextElement(child);\n      })\n    })\n  };\n}\n\nfunction createTextElement(text) {\n  return {\n    type: 'TEXT_ELEMENT',\n    props: {\n      nodeValue: text,\n      children: []\n    }\n  };\n}\n\nfunction createDom(fiber) {\n  var dom = fiber.type == \"TEXT_ELEMENT\" ? document.createTextNode(\"\") : document.createElement(fiber.type);\n  updateDom(dom, {}, fiber.props);\n  return dom;\n}\n\nvar isEvent = function isEvent(key) {\n  return key.startsWith('on');\n};\n\nvar isProperty = function isProperty(key) {\n  return key !== 'children' && !isEvent(key);\n};\n\nvar isNew = function isNew(prev, next) {\n  return function (key) {\n    return prev[key] !== next[key];\n  };\n};\n\nvar isGone = function isGone(prev, next) {\n  return function (key) {\n    return !(key in next);\n  };\n};\n\nfunction updateDom(dom, prevProps, nextProps) {\n  //Remove old or changed event listeners\n  Object.keys(prevProps).filter(isEvent).filter(function (key) {\n    return !(key in nextProps) || isNew(prevProps, nextProps)(key);\n  }).forEach(function (name) {\n    var eventType = name.toLowerCase().substring(2);\n    dom.removeEventListener(eventType, prevProps[name]);\n  }); // Add event listeners\n\n  Object.keys(nextProps).filter(isEvent).filter(isNew(prevProps, nextProps)).forEach(function (name) {\n    var eventType = name.toLowerCase().substring(2);\n    dom.addEventListener(eventType, nextProps[name]);\n  }); // Remove old properties\n\n  Object.keys(prevProps).filter(isProperty).filter(isGone(prevProps, nextProps)).forEach(function (name) {\n    dom[name] = '';\n  }); // Set new or changed properties\n\n  Object.keys(nextProps).filter(isProperty).filter(isNew(prevProps, nextProps)).forEach(function (name) {\n    dom[name] = nextProps[name];\n  });\n}\n\nfunction commitRoot() {\n  // TODO add nodes to dom\n  deletions.forEach(commitWork);\n  commitWork(wipRoot.child);\n  currentRoot = wipRoot;\n  wipRoot = null;\n}\n\nfunction commitWork(fiber) {\n  if (!fiber) return; // Now that we have fibers without DOM nodes we need to change in FC supported\n  // const domParent = fiber.parent.dom\n\n  var domParentFiber = fiber.parent;\n\n  while (!domParentFiber.dom) {\n    domParentFiber = domParentFiber.parent;\n  }\n\n  var domParent = domParentFiber.dom; // domParent.appendChild(fiber.dom);\n\n  if (fiber.effectTag === 'PLACEMENT' && fiber.dom != null) {\n    domParent.appendChild(fiber.dom);\n  } else if (fiber.effectTag === 'UPDATE' && fiber.dom != null) {\n    updateDom(fiber.dom, fiber.alternate.props, fiber.props);\n  } else if (fiber.effectTag === 'DELETION') {\n    commitDeletion(fiber, domParent);\n  }\n\n  commitWork(fiber.child);\n  commitWork(fiber.sibling);\n}\n\nfunction commitDeletion(fiber, domParent) {\n  if (fiber.dom) {\n    domParent.removeChild(fiber.dom);\n  } else {\n    commitDeletion(fiber.child, domParent);\n  }\n}\n\nfunction render(element, container) {\n  // const dom =\n  //   element.type === 'TEXT_ELEMENT'\n  //     ? document.createTextNode('')\n  //     : document.createElement(element.type);\n  // const isProperty = (key) => key !== 'children';\n  // Object.keys(element.props).filter(isProperty).forEach(name => {\n  //   dom[name] = element.props[name];\n  // })\n  // element.props.children.forEach((child) => render(child, dom));\n  // container.appendChild(dom);\n  wipRoot = {\n    dom: container,\n    props: {\n      children: [element]\n    },\n    alternate: currentRoot\n  };\n  deletions = [];\n  nextUnitOfWork = wipRoot;\n}\n\nvar nextUnitOfWork = null;\nvar wipRoot = null;\nvar currentRoot = null;\nvar deletions = null;\n\nfunction workLoop(deadline) {\n  var shouldYield = false;\n\n  while (nextUnitOfWork && !shouldYield) {\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    shouldYield = deadline.timeRemaining() < 1;\n  }\n\n  if (!nextUnitOfWork && wipRoot) {\n    commitRoot();\n  }\n\n  requestIdleCallback(workLoop);\n}\n\nrequestIdleCallback(workLoop);\n\nfunction performUnitOfWork(fiber) {\n  // if (!fiber.dom) {\n  //   fiber.dom = createDom(fiber);\n  // }\n  // // remove because the browser could interrupt our work before we finish rendering the whole tree\n  // // if (fiber.parent) {\n  // //   fiber.parent.dom.appendDom(fiber.dom);\n  // // }\n  // const elements = fiber.props.children;\n  // reconcileChildren(fiber, elements);\n  var isFunctionComponent = fiber.type instanceof Function;\n\n  if (isFunctionComponent) {\n    updateFunctionComponent(fiber);\n  } else {\n    updateHostComponent(fiber);\n  }\n\n  if (fiber.child) {\n    return fiber.child;\n  }\n\n  var nextFiber = fiber;\n\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling;\n    }\n\n    nextFiber = nextFiber.parent;\n  }\n}\n\nvar wipFiber = null;\nvar hookIndex = null;\n\nfunction updateFunctionComponent(fiber) {\n  wipFiber = fiber;\n  hookIndex = 0;\n  wipFiber.hooks = [];\n  var children = [fiber.type(fiber.props)];\n  reconcileChildren(fiber, children);\n}\n\nfunction useState(initial) {\n  var oldHook = wipFiber.alternate && wipFiber.alternate.hooks && wipFiber.alternate.hooks[hookIndex];\n  var hook = {\n    state: oldHook ? oldHook.state : initial,\n    queue: []\n  };\n  var actions = oldHook ? oldHook.queue : [];\n  actions.forEach(function (action) {\n    hook.state = action(hook.state);\n  });\n\n  var setState = function setState(action) {\n    hook.queue.push(action);\n    wipRoot = {\n      dom: currentRoot.dom,\n      props: currentRoot.props,\n      alternate: currentRoot\n    };\n    nextUnitOfWork = wipRoot;\n    deletions = [];\n  };\n\n  wipFiber.hooks.push(hook);\n  hookIndex++;\n  return [hook.state, setState];\n}\n\nfunction updateHostComponent(fiber) {\n  if (!fiber.dom) {\n    fiber.dom = createDom(fiber);\n  } // remove because the browser could interrupt our work before we finish rendering the whole tree\n  // if (fiber.parent) {\n  //   fiber.parent.dom.appendDom(fiber.dom);\n  // }\n\n\n  var elements = fiber.props.children;\n  reconcileChildren(fiber, elements);\n}\n\nfunction reconcileChildren(wipFiber, elements) {\n  var index = 0;\n  var oldFiber = wipFiber.alternate && wipFiber.alternate.child;\n  var prevSibling = null;\n\n  while (index < elements.length || oldFiber != null) {\n    var _element = elements[index];\n    var newFiber = null; // const newFiber = {\n    //   type: element.type,\n    //   props: element.props,\n    //   parent: wipFiber,\n    //   dom: null\n    // }\n    // compare oldFiber to element\n\n    var sameType = oldFiber && _element && _element.type == oldFiber.type;\n\n    if (sameType) {\n      // update the node\n      newFiber = {\n        type: oldFiber.type,\n        props: _element.props,\n        dom: oldFiber.dom,\n        parent: wipFiber,\n        alternate: oldFiber,\n        effectTag: 'UPDATE'\n      };\n    }\n\n    if (_element && !sameType) {\n      // add the node\n      newFiber = {\n        type: _element.type,\n        props: _element.props,\n        dom: null,\n        parent: wipFiber,\n        alternate: null,\n        effectTag: 'PLACEMENT'\n      };\n    }\n\n    if (oldFiber && !sameType) {\n      // delete the node\n      oldFiber.effectTag = 'DELETION';\n      deletions.push(oldFiber);\n    }\n\n    if (oldFiber) {\n      oldFiber = oldFiber.sibling;\n    }\n\n    if (index === 0) {\n      wipFiber.child = newFiber;\n    } else {\n      prevSibling.sibling = newFiber;\n    }\n\n    prevSibling = newFiber;\n    index++;\n  }\n}\n/** @jsxRuntime classic */\n\n/** @jsx Didact.createElement */\n\n\nfunction Counter() {\n  _s();\n\n  var _Didact$useState = Didact.useState(1),\n      _Didact$useState2 = _slicedToArray(_Didact$useState, 2),\n      state = _Didact$useState2[0],\n      setState = _Didact$useState2[1];\n\n  return Didact.createElement(\"h1\", {\n    onClick: function onClick() {\n      return setState(function (c) {\n        return c + 1;\n      });\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 309,\n      columnNumber: 10\n    }\n  }, \"Count: \", state);\n}\n\n_s(Counter, \"akakBhCEomgH04pZyWr7fNqgJTI=\");\n\n_c = Counter;\nvar element = Didact.createElement(Counter, {\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 311,\n    columnNumber: 17\n  }\n});\nvar container = document.getElementById('root');\nDidact.render(element, container);\n\nvar _c;\n\n$RefreshReg$(_c, \"Counter\");","map":{"version":3,"sources":["/Users/houyaodong/test/react/300line/src/index.js"],"names":["Didact","createElement","render","useState","type","props","children","map","child","createTextElement","text","nodeValue","createDom","fiber","dom","document","createTextNode","updateDom","isEvent","key","startsWith","isProperty","isNew","prev","next","isGone","prevProps","nextProps","Object","keys","filter","forEach","name","eventType","toLowerCase","substring","removeEventListener","addEventListener","commitRoot","deletions","commitWork","wipRoot","currentRoot","domParentFiber","parent","domParent","effectTag","appendChild","alternate","commitDeletion","sibling","removeChild","element","container","nextUnitOfWork","workLoop","deadline","shouldYield","performUnitOfWork","timeRemaining","requestIdleCallback","isFunctionComponent","Function","updateFunctionComponent","updateHostComponent","nextFiber","wipFiber","hookIndex","hooks","reconcileChildren","initial","oldHook","hook","state","queue","actions","action","setState","push","elements","index","oldFiber","prevSibling","length","newFiber","sameType","Counter","c","getElementById"],"mappings":"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","sourcesContent":["const Didact = {\n  createElement,\n  render,\n  useState,\n};\n\nfunction createElement(type, props, ...children) {\n  return {\n    type,\n    props: {\n      ...props,\n      children: children.map((child) =>\n        typeof child === 'object' ? child : createTextElement(child)\n      ),\n    },\n  };\n}\n\nfunction createTextElement(text) {\n  return {\n    type: 'TEXT_ELEMENT',\n    props: {\n      nodeValue: text,\n      children: [],\n    },\n  };\n}\n\nfunction createDom(fiber) {\n  const dom =\n    fiber.type == \"TEXT_ELEMENT\"\n      ? document.createTextNode(\"\")\n      : document.createElement(fiber.type)\n\n  updateDom(dom, {}, fiber.props)\n\n  return dom\n}\n\nconst isEvent = (key) => key.startsWith('on');\nconst isProperty = (key) => key !== 'children' && !isEvent(key);\nconst isNew = (prev, next) => (key) => prev[key] !== next[key];\nconst isGone = (prev, next) => (key) => !(key in next);\n\nfunction updateDom(dom, prevProps, nextProps) {\n  //Remove old or changed event listeners\n  Object.keys(prevProps)\n    .filter(isEvent)\n    .filter((key) => !(key in nextProps) || isNew(prevProps, nextProps)(key))\n    .forEach((name) => {\n      const eventType = name.toLowerCase().substring(2);\n      dom.removeEventListener(eventType, prevProps[name]);\n    });\n  // Add event listeners\n  Object.keys(nextProps)\n    .filter(isEvent)\n    .filter(isNew(prevProps, nextProps))\n    .forEach((name) => {\n      const eventType = name.toLowerCase().substring(2);\n      dom.addEventListener(eventType, nextProps[name]);\n    });\n  // Remove old properties\n  Object.keys(prevProps)\n    .filter(isProperty)\n    .filter(isGone(prevProps, nextProps))\n    .forEach((name) => {\n      dom[name] = '';\n    });\n  // Set new or changed properties\n  Object.keys(nextProps)\n    .filter(isProperty)\n    .filter(isNew(prevProps, nextProps))\n    .forEach((name) => {\n      dom[name] = nextProps[name];\n    });\n}\n\nfunction commitRoot() {\n  // TODO add nodes to dom\n  deletions.forEach(commitWork);\n  commitWork(wipRoot.child);\n  currentRoot = wipRoot;\n  wipRoot = null;\n}\n\nfunction commitWork(fiber) {\n  if (!fiber) return;\n  // Now that we have fibers without DOM nodes we need to change in FC supported\n  // const domParent = fiber.parent.dom\n  let domParentFiber = fiber.parent;\n  while (!domParentFiber.dom) {\n    domParentFiber = domParentFiber.parent;\n  }\n  const domParent = domParentFiber.dom;\n\n  // domParent.appendChild(fiber.dom);\n  if (fiber.effectTag === 'PLACEMENT' && fiber.dom != null) {\n    domParent.appendChild(fiber.dom);\n  } else if (fiber.effectTag === 'UPDATE' && fiber.dom != null) {\n    updateDom(fiber.dom, fiber.alternate.props, fiber.props);\n  } else if (fiber.effectTag === 'DELETION') {\n    commitDeletion(fiber, domParent);\n  }\n  commitWork(fiber.child);\n  commitWork(fiber.sibling);\n}\n\nfunction commitDeletion(fiber, domParent) {\n  if (fiber.dom) {\n    domParent.removeChild(fiber.dom);\n  } else {\n    commitDeletion(fiber.child, domParent);\n  }\n}\n\nfunction render(element, container) {\n  // const dom =\n  //   element.type === 'TEXT_ELEMENT'\n  //     ? document.createTextNode('')\n  //     : document.createElement(element.type);\n  // const isProperty = (key) => key !== 'children';\n  // Object.keys(element.props).filter(isProperty).forEach(name => {\n  //   dom[name] = element.props[name];\n  // })\n  // element.props.children.forEach((child) => render(child, dom));\n  // container.appendChild(dom);\n  wipRoot = {\n    dom: container,\n    props: {\n      children: [element],\n    },\n    alternate: currentRoot,\n  };\n  deletions = [];\n  nextUnitOfWork = wipRoot;\n}\n\nlet nextUnitOfWork = null;\nlet wipRoot = null;\nlet currentRoot = null;\nlet deletions = null;\n\nfunction workLoop(deadline) {\n  let shouldYield = false;\n  while (nextUnitOfWork && !shouldYield) {\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    shouldYield = deadline.timeRemaining() < 1;\n  }\n\n  if (!nextUnitOfWork && wipRoot) {\n    commitRoot();\n  }\n  requestIdleCallback(workLoop);\n}\n\nrequestIdleCallback(workLoop);\n\nfunction performUnitOfWork(fiber) {\n  // if (!fiber.dom) {\n  //   fiber.dom = createDom(fiber);\n  // }\n\n  // // remove because the browser could interrupt our work before we finish rendering the whole tree\n  // // if (fiber.parent) {\n  // //   fiber.parent.dom.appendDom(fiber.dom);\n  // // }\n\n  // const elements = fiber.props.children;\n  // reconcileChildren(fiber, elements);\n\n  const isFunctionComponent = fiber.type instanceof Function;\n  if (isFunctionComponent) {\n    updateFunctionComponent(fiber);\n  } else {\n    updateHostComponent(fiber);\n  }\n\n  if (fiber.child) {\n    return fiber.child;\n  }\n  let nextFiber = fiber;\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling;\n    }\n    nextFiber = nextFiber.parent;\n  }\n}\n\nlet wipFiber = null;\nlet hookIndex = null;\nfunction updateFunctionComponent(fiber) {\n  wipFiber = fiber;\n  hookIndex = 0;\n  wipFiber.hooks = [];\n  const children = [fiber.type(fiber.props)];\n  reconcileChildren(fiber, children);\n}\n\nfunction useState(initial) {\n  const oldHook =\n    wipFiber.alternate &&\n    wipFiber.alternate.hooks &&\n    wipFiber.alternate.hooks[hookIndex];\n  const hook = {\n    state: oldHook ? oldHook.state : initial,\n    queue: []\n  };\n  const actions = oldHook ? oldHook.queue : []\n  actions.forEach(action => {\n    hook.state = action(hook.state)\n  })\n  \n  const setState = action => {\n    hook.queue.push(action);\n    wipRoot = {\n      dom: currentRoot.dom,\n      props: currentRoot.props,\n      alternate: currentRoot\n    }\n    nextUnitOfWork = wipRoot;\n    deletions = [];\n  };\n  wipFiber.hooks.push(hook)\n  hookIndex++\n  return [hook.state, setState]\n}\n\nfunction updateHostComponent(fiber) {\n  if (!fiber.dom) {\n    fiber.dom = createDom(fiber);\n  }\n\n  // remove because the browser could interrupt our work before we finish rendering the whole tree\n  // if (fiber.parent) {\n  //   fiber.parent.dom.appendDom(fiber.dom);\n  // }\n\n  const elements = fiber.props.children;\n  reconcileChildren(fiber, elements);\n}\n\nfunction reconcileChildren(wipFiber, elements) {\n  let index = 0;\n  let oldFiber = wipFiber.alternate && wipFiber.alternate.child;\n  let prevSibling = null;\n\n  while (index < elements.length || oldFiber != null) {\n    const element = elements[index];\n    let newFiber = null;\n\n    // const newFiber = {\n    //   type: element.type,\n    //   props: element.props,\n    //   parent: wipFiber,\n    //   dom: null\n    // }\n\n    // compare oldFiber to element\n    const sameType = oldFiber && element && element.type == oldFiber.type;\n\n    if (sameType) {\n      // update the node\n      newFiber = {\n        type: oldFiber.type,\n        props: element.props,\n        dom: oldFiber.dom,\n        parent: wipFiber,\n        alternate: oldFiber,\n        effectTag: 'UPDATE',\n      };\n    }\n    if (element && !sameType) {\n      // add the node\n      newFiber = {\n        type: element.type,\n        props: element.props,\n        dom: null,\n        parent: wipFiber,\n        alternate: null,\n        effectTag: 'PLACEMENT',\n      };\n    }\n    if (oldFiber && !sameType) {\n      // delete the node\n      oldFiber.effectTag = 'DELETION';\n      deletions.push(oldFiber);\n    }\n\n    if (oldFiber) {\n      oldFiber = oldFiber.sibling;\n    }\n\n    if (index === 0) {\n      wipFiber.child = newFiber;\n    } else {\n      prevSibling.sibling = newFiber;\n    }\n\n    prevSibling = newFiber;\n    index++;\n  }\n}\n\n/** @jsxRuntime classic */\n/** @jsx Didact.createElement */\nfunction Counter() {\n  const [state, setState] = Didact.useState(1);\n  return <h1 onClick={() => setState((c) => c + 1)}>Count: {state}</h1>;\n}\nconst element = <Counter />;\nconst container = document.getElementById('root');\nDidact.render(element, container);\n"]},"metadata":{},"sourceType":"module"}